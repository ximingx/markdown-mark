## 知识点检查

![image-20220326213323245](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203272318306.png)

![image-20220326213602852](https://github.com/ximingx/Figurebed/blob/master/img/image-20220326213602852.png?raw=true)

## 计算机组成与体系结构

### 1. 数据的表示

#### 进制转换

任何进制转换为十进制采用按权展开法

```js
eg: 10100.01(2) => (10) {
  1 * 2^4 + 1 * 2^2 + 1 * 2^(-2) 
}

eg: 604.01(7) => (10) {
  6 * 7^2 + 4 * 7^0 + 1 * 7^(-2)
}

eg: 678(9) => (10) {
  6 * 9^2 + 7 * 9^1 + 8 * 9^0 = 557
}
```

十进制转换任何进制使用短除法

```js
eg: 64(10) => (2) {
	2 64 0
  2 32 0
  2 16 0
  2 8 0
  2 4 0
  2 2 0
  2 1 1
} = 1000000

eg: 79(10) => (8) {
  8 79 7 
  8 9 1
  8 1 1
} = 117

eg: 678(10) => (16) {
  16 678 6
  16 42 A 
  16 2 2
} = 2A6
```

二进制 => 八进制 || 二进制 => 十六进制

```js
eg: 10 001 110(2) => (8) {
  2 1 6 
} = 216

eg: 1000 1110(2) => (16) {
  8 E
} = 8E

eg: 101 010 000(2) => (8) {
  5 2 0
} = 520
```

八进制 => 十六进制

```js
eg: 145(8) => (16) {
  1 * 8^2 + 4 * 8^1 + 5*8^0 = 101(10)
  16 101 5
  16 6 6
} = 65
```

#### 原码反码补码移码

![image-20220326225854348](https://github.com/ximingx/Figurebed/blob/master/img/image-20220326225854348.png?raw=true)

原码： 把这个数字转换为二进制， 最高位是符号位（正数为0， 负数为1）， 如果分配的大小是一个字节， 那么他就是八位，不足补0 （原码的运算与正常的运算不同， 不可以用做机器操作的计算）

反码： 正数的反码与原码相同， 负数的反码等于原码除了符号位以外的值取反 

补码： 正数的补码与原码相同， 负数的补码等于反码的基础上加1

移码： 只改变符号位 （一般用于浮点数运算做阶码）

表示的取值范围： 

![image-20220326230653243](https://github.com/ximingx/Figurebed/blob/master/img/image-20220326230653243.png?raw=true)

补码的取值范围大于原码和反码， 原因是补码中 0 的正值和负值用一个数表示

## 2. 设计模式

### 观察者模式

定义： 定义对象之间的一对多依赖， 让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时他的所有依赖者都会收到通知并更新

```java
package Observer;

import java.util.ArrayList;
import java.util.List;

public class ObserverTest {

    public static void main(String[] args) {

        Subject subject = new Subject();
        Task1 task1 = new Task1();
        subject.addObserver(task1);
        Task2 task2 = new Task2();
        subject.addObserver(task2);
        subject.notifyObserver("数据第二次改变");
        System.out.println("--------------------------");
        subject.removeObserver(task1);
        subject.notifyObserver("数据第一次改变");

    }

}

// 定义了一个主题类
class Subject {
    // 观察者（任务）的容器
    private List<Observer> containers = new ArrayList<>();
    // 增加观察者 （任务）
    public void addObserver(Observer observer) {
        containers.add(observer);
    }
    // 删除观察者 （任务）
    public void removeObserver(Observer observer) {
        containers.remove(observer);
    }
    // 通知所有观察者 （发布所有的任务）
    public void notifyObserver(Object object) {
        for (Observer item: containers) {
            item.update(object);
        }
    }
}

// 观察者接口
interface Observer {

    void update(Object object);

}

// 实际任务1
class Task1 implements Observer {

    @Override
    public void update(Object object) {
        System.out.println("Task1 received" + object);
    }

}

// 实际任务2
class Task2 implements Observer {

    @Override
    public void update(Object object) {
        System.out.println("Task2 received" + object);
    }

}
```

优点： 

1. 符合开闭原则， 在不改变原来的基础上， 可以轻松的添加监听者
2. 可以在运行时建立对象之间的关系

### 命令模式

```java
package Design.CommandTest;

public class CommandTest {

    public static void main(String[] args) {

        SaveButton saveButton = new SaveButton();
        TextBox box = new TextBox();

        PrintCommand printCommand = new PrintCommand(box);
        saveButton.bindCommand(printCommand);

        box.setContext("啊呜啊呜");
        saveButton.doPrint();

    }

}


class SaveButton {

    private Command command;

    public void bindCommand(Command command) {
        this.command = command;
    }

    public void doPrint() {
        command.execute();
    }

}

class PrintService {

    public void print(String text) {
        System.out.println(text);
    }

}

interface Command {
    void execute();
}

class PrintCommand implements Command {

    private PrintService serviceProvider = new PrintService();
    private  TextBox box;

    public PrintCommand(TextBox box) {
        this.box = box;
    }

    @Override
    public void execute() {
        serviceProvider.print(box.getContext());
    }

}

class TextBox {

    private String context;

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }

}
```

### 装饰模式

定义： 在不改变对象原有功能的基础上， 将功能附加到对象上（只是装饰， 并非完全需要使用）

```java
package DecoratorTest;

public class DecoratorTest {

    public static void main(String[] args) {

        Component component = new ConcreteComponent();
        component.operation();

        System.out.println("--------------------");

        Component addComponent = new ConcreteDecorate2(new ConcreteDecorate1(new ConcreteComponent()));
        addComponent.operation();


    }

}

// 应用接口
interface Component {

    void operation();

}

// 具体基础功能的实现
class ConcreteComponent implements  Component {

    @Override
    public void operation() {
        System.out.println("拍照");
    }

}

// 这个接口用来拓展基础功能
abstract class Decorate implements Component {

    Component component;

    public Decorate(Component component) {
        this.component = component;
    }

}

// 具体的实现拓展功能 1
class ConcreteDecorate1 extends Decorate {

    public ConcreteDecorate1(Component component) {
        super(component);
    }

    @Override
    public void operation() {

        component.operation();
        System.out.println("添加美颜");
    }

}

// 具体的实现拓展功能 2
class ConcreteDecorate2 extends Decorate {

    public ConcreteDecorate2(Component component) {
        super(component);
    }

    @Override
    public void operation() {

        component.operation();
        System.out.println("添加滤镜");
    }

}
```

应用场景： 

1. 拓展一个类的功能， 给一个类添加附加职责

优点： 

1. 在不改变原有对象的情况下给对象一个拓展功能

2. 使用不同的组合可以有不同的效果

3. 符合开闭原则

### 适配器模式

定义： 将一个类的接口转换为用户希望的另一个接口， 使得原本不能兼容的接口得以一起工作

#### 对象适配器

```java
package Design.Adapter;

public class AdapterTest1 {

    public static void main(String[] args) {
        // 对象适配器模式 (写法一)
        Adaptee adaptee = new Adaptee();
        Target target = new Adapter(adaptee);
        target.output5v();

    }

}

// 原始电压
class Adaptee {

    public int output220v() {
        return 220;
    }

}

// 目标适配电压
interface Target {

    int output5v();

}

// 适配器
class Adapter implements Target {

    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public int output5v() {
        int i = adaptee.output220v();
        System.out.println("原始电压： " + i + "v; -> 输出电压： 5v");
        return 5;
    }

}
```

#### 类适配器模式

```java
package Design.Adapter;

public class AdapterTest2 {

    public static void main(String[] args) {
        // 类适配器模式 (写法二)
        Adapter adapter = new Adapter();
        adapter.output5v();
    }

}

// 原始
class Adaptee {

    public int output220v() {
        return 220;
    }

}

// 目标
interface Target {
    int output5v();
}

// 适配器
class Adapter extends Adaptee implements Target {

    @Override
    public int output5v() {
        int i = output220v();
        // ~ ~ ~
        System.out.println("原始电压： " + i + "v; -> 输出电压： 5v");
        return 5;
    }

}
```

优点： 

符合单一职责原则

符合开闭原则

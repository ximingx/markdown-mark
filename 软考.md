## 学习策略

### 1. 快速过一遍视频（5 天）

视频教程推荐王勇老师讲授的。b 站链接：[软件设计师考试教程](https://www.bilibili.com/video/BV1rW411j7e7?from=search&seid=9540090189214316110&spm_id_from=333.337.0.0)

当我们快速观看了一遍视频，我们就相对有底了，也能建立起基本的（尽管可能是模糊的）知识架构。

### 2. 逐章细看视频，逐章刷选择题（45 天）

真题 app 推荐【软考通】。豌豆荚链接：[软考通](https://www.wandoujia.com/apps/8095598)

共分 16 章。在这一步，我们应该认真听讲完一章后，就完成对应章节的选择题（也就是上午题）。每一章【看视频 + 做题】，大约花费 2~3 天。因此**建议 45 天内完成**。

*真题 app 和视频的章节划分有所不同，但大致可以对应。*

### 3. 分类攻破下午题（应用技术）（15 天）

下午的应用技术题型是固定的，共 6 道题，最后两道二选一：

1. 结构化分析与设计，考查数据流图 DFD
2. 数据库的分析和设计，考查 ER 图与关系模式
3. 面向对象分析与设计，考查常用 UML 图
4. 常用数据结构和算法（C 语言）
5. 设计模式（C++ 和 Java 二选一）

在这一步，我们可以一次复习一种题型对应的视频，然后，一次大量练习攻克【**一种题型**】。例如看了数据流图相关的视频后，我们可以把多年的数据流图真题都打印出来，一次性吃透数据流图题。每种题型花费 2~3 天，因此**建议 15 天内完成**。

### 4. 熟悉 C 和 Java 的基本语法

有些同学可能没使用过 C 和 Java，这里推荐翁恺老师的课程：

* [程序设计入门——C语言](https://www.icourse163.org/course/0809ZJU007A-199001?outVendor=zw_mooc_pclszykctj_)
* [C语言程序设计进阶](https://www.icourse163.org/course/0809ZJU007B-200001?outVendor=zw_mooc_pclszykctj_)
* [零基础学Java语言](https://www.icourse163.org/course/0809ZJU013-1001541001?outVendor=zw_mooc_pclszykctj_)
* [面向对象程序设计——Java语言](https://www.icourse163.org/course/0809ZJU012-1001542001?outVendor=zw_mooc_pclszykctj_)

*因为在下选做的是 Java，所以没有 C++ 的推荐课程。*

### 5. 真题与答案可能有错谬

实际上，软考办官方从来没有公布过真题与答案。网上流传的真题与答案，是考友的回忆或是其他非常规渠道获得的。题目大致上没问题，但是答案真的仅仅是【参考答案】。当然，经过考友的讨论与整理，这些答案正确率还是比较高的。因此，对于参考答案，【**不可不信，不可全信**】。

### 6. 课本可当作文档查阅

通读课本的时间成本相当高，相关知识点也比较难以理解。因此，我们可以把课本可当作文档查阅，遇到有疑义的地方，再查阅甄别。

### 7. 考前一周刷整卷

经过上面的步骤后，我们对“软件设计师”的知识点已经掌握得比较扎实。可在考前一周把近五年的真题试卷打印出来，给自己进行模拟考。这样既能熟悉试卷结构，又能保持题感。

最后，祝大家都顺利一次过考。

## 知识点检查

![image-20220326213323245](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203272318306.png)

![image-20220326213602852](https://github.com/ximingx/Figurebed/blob/master/img/image-20220326213602852.png?raw=true)

## 计算机组成与体系结构

### 数据的表示

#### 1. 进制转换

任何进制转换为十进制采用按权展开法

```js
eg: 10100.01(2) => (10) {
  1 * 2^4 + 1 * 2^2 + 1 * 2^(-2) 
}

eg: 604.01(7) => (10) {
  6 * 7^2 + 4 * 7^0 + 1 * 7^(-2)
}

eg: 678(9) => (10) {
  6 * 9^2 + 7 * 9^1 + 8 * 9^0 = 557
}
```

十进制转换任何进制使用短除法

```js
eg: 64(10) => (2) {
	2 64 0
  2 32 0
  2 16 0
  2 8 0
  2 4 0
  2 2 0
  2 1 1
} = 1000000

eg: 79(10) => (8) {
  8 79 7 
  8 9 1
  8 1 1
} = 117

eg: 678(10) => (16) {
  16 678 6
  16 42 A 
  16 2 2
} = 2A6
```

二进制 => 八进制 || 二进制 => 十六进制

```js
eg: 10 001 110(2) => (8) {
  2 1 6 
} = 216

eg: 1000 1110(2) => (16) {
  8 E
} = 8E

eg: 101 010 000(2) => (8) {
  5 2 0
} = 520
```

八进制 => 十六进制

```js
eg: 145(8) => (16) {
  1 * 8^2 + 4 * 8^1 + 5*8^0 = 101(10)
  16 101 5
  16 6 6
} = 65
```

#### 2. 原码反码补码移码

![image-20220326225854348](https://github.com/ximingx/Figurebed/blob/master/img/image-20220326225854348.png?raw=true)

原码： 把这个数字转换为二进制， 最高位是符号位（正数为0， 负数为1）， 如果分配的大小是一个字节， 那么他就是八位，不足补0 （原码的运算与正常的运算不同， 不可以用做机器操作的计算）

反码： 正数的反码与原码相同， 负数的反码等于原码除了符号位以外的值取反 

补码： 正数的补码与原码相同， 负数的补码等于反码的基础上加1

移码： 只改变符号位 （一般用于浮点数运算做阶码）

表示的取值范围： 

![image-20220326230653243](https://github.com/ximingx/Figurebed/blob/master/img/image-20220326230653243.png?raw=true)

补码的取值范围大于原码和反码， 原因是补码中 0 的正值和负值用一个数表示

#### 3. 浮点数

浮点数的 `.` 之前的位数必须是一

在进行运算的时候， 要保持阶位相同

###  计算机结构

#### 1. CPU结构 （运算器， 控制器）

![image-20220328224937309](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203282249354.png)

#### 2. Flynn 分类法

![image-20220328230527764](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203282305817.png)

#### 3. SISC 和 RISC

![image-20220328231141363](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203282311410.png)

#### 4. 流水线

![image-20220328233121128](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203282331170.png)

> eg： 

![image-20220328233736296](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203282337340.png)

```js
// 流水线的周期选择指令中时间最长的一段（取指，分析，执行）
> 流水线周期 2s
// 理论计算 => 启动时间 + （指令条数 - 1）* 流水线周期 
> 2 + 2 + 1 + （100 - 1） * 2 = 203ns
// 实际计算 => (流水线周期步骤数量 + 指令数量 - 1) * 流水线周期
> (3 + 100 - 1) * 2 = 204ns
// 优先采用理论计算结果 （有争议）
```

![image-20220329102007647](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291020718.png)

```js
// 流水线的吞吐率
> TP = 100 / 203ns
// 流水线的最大吞吐率
> TPMAX = 1 / 2ns
```

![image-20220329102302819](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291023863.png)

```js
// 流水线加速比
> s = 5 * 100 / 203	
// 加速比越高越好
```

![image-20220329102507650](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291025786.png)

```js
// 在利用的时间片 / 总共夺得时间片 
(t + t + t + 3t) * 4 / 15 * 4
// 衡量空间的利用率
// 在每一个步骤的时间相同时，效率最高
```

#### 5. 层次化存储结构

![image-20220329103619208](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291036273.png)

基于性价比的考虑， 引入 cache 

![image-20220329104531522](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291045624.png)

![image-20220329105301461](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291053538.png)

![image-20220329105315949](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291053003.png)

![image-20220329105444465](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291054568.png)

```js
// 空间大小 大的内存空间 - 小的内存空间 + 1
> 内存单元： C8000H - AC000H = 1C000H
> 1C000H = 1 * 16^4 + 12 * 16*3 = 65536 + 49152 
> 1C000H / 2^10 = 112K
// 存储位数
112K * 16 / 28 / 16K / n = 1
n = 4
```

![image-20220329111048654](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291110725.png)

![image-20220329111421719](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291114794.png)

```js
// 最长时间
>（33 + 3） * 10 + 3 + 3 = 366
// 优化时间
> (3 + 3) * 11 = 66
```

#### 6. 总线

![image-20220329112514624](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291125686.png)

#### 7. 系统可考虑分析

串联模型

![image-20220329112911715](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291129800.png)

并联模型

![image-20220329113115510](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291131574.png)

混合模型

![image-20220329113439989](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291134121.png)

#### 8. 差错控制，海明校验码

![image-20220329113642371](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291136504.png)

一个码字改变几位， 才可以变为了一个合法码字，码距就是那个位数

![image-20220329114328837](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291143905.png)

模二除法 => 异或操作： 同0异1 

二进制除法

![image-20220329115254294](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291152439.png)

```js
// 原始报文： 11001010101
// 生成多项式： x^4 + x^3 + x + 1 = 11011
// 原始报文后加 （生成多项式的位数 - 1）位的0 （目的： 补余数位数）
// 进行 11001010101 0000 模二除法 11011
// 在换算出最后的结果以后 0011 将其替代 0000
// 或得完整信息11001010101 0011 
// 完整信息 和 生产多项式 进行模二除法
如果余数位 0 结果正确
```

![image-20220329135609267](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291356356.png)

```java
// 校验位： 2^n  即  1, 2, 4, 8 ……
// 满足 2^r >= x + r + 1; x为数据位， r为校验位
```

## 操作系统原理

![image-20220403104531422](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204031049769.png)

### 进程管理

#### 1. 三态模型

![image-20220403105335050](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204031053099.png)

```java
// 三态模型 上提供了 静止就绪和静止阻塞 
// 挂起， 并不是缺少资源， 而是暂时不处理
```

#### 2.前趋图

![image-20220403110258546](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204031102659.png)

#### 3. 进程的同步与互斥

![image-20220403110952436](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204031109491.png)

#### 4. pv 操作

![image-20220404084056985](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204040840055.png)

```java
// 需要注意的是 
// p 操作的判断是 s < 0 
// v 操作的判断是 <= 0
// 满足条件后进入进程队列，进行阻塞
```

![image-20220404095155835](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204040951029.png)

```java
// 付款不只是顾客的单一操作
// 收费不只是收银员的单一操作
// 需要双方的配合， 有同步的关系
// 总结： 谁需要等待别人的回应， 谁进行 p 操作
```

![image-20220404095857897](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204040958976.png)

![image-20220404100133405](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041001458.png)

```js
// 谁需要等待别人的回应， 谁进行 p 操作
// 例如： d 等待 a，b，c 的执行 d 进行 p 操作
```

![image-20220404100741015](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041011474.png)

#### 5. 死锁问题

![image-20220404101103752](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041011814.png)

```js
// 当每一个进程分配的资源都为总数 - 1时， 最后所以进程的总数 + 1 不可能发生死锁
// 即 13 个
```

### 存储管理

#### 1. 存储分配方法

![image-20220404101737547](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041017599.png)

```js
// 内存的分配是动态分配的 
// 首次适用法： 第一次找到符合要求的
// 最佳适用法： 将所有剩余的空间由小达到大排列， 优先选择最小且能完整容纳的空间
// 最差适用算法： 将所有剩余的空间由小达到大排列， 优先选择最大且能完整容纳的空间切割出来
// 循环首次适用算法： 将所有剩余的空间连成环状， 顺次使用
```

#### 2. 页式存储方式

![image-20220404104905250](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041049301.png)

![image-20220404152739407](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041527468.png)

```js
// 4k = 10^ 12 页内地址为12位 
// 转为 16 进制对应后三位
// 物理地址为： 页号对应的页帧号的值 拼接上 后三位 
// 淘汰的页面必须是未被访问的页面
```

#### 3. 段式存储

![image-20220404153404532](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041534635.png)

```js
// 段号 段长 基址
```

#### 4. 段页式存储

![image-20220404153727405](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041537458.png)

#### 5. 快表

![image-20220404153826758](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041538810.png)

#### 6. 页面置换算法

![image-20220404153900482](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041539535.png)

![image-20220404154546848](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041545906.png)

```js
// 缺页： 内存中找不到时认为是缺页
// 抖动： 占用跟多的资源， 但是缺页的次数却比跟少资源的次数多
// 先进先出出算法 与 lru 算法的区别
// lru 主张的事最近谁使用的次数最少， 替换掉谁
```

![image-20220404155032051](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041550114.png)

![image-20220404155539901](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041555962.png)

### 文件管理

#### 1. 索引文件结构

![image-20220404155720708](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041557784.png)

![image-20220404160350433](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041603503.png)

#### 8. 文件和树形目录结构

![image-20220404160516250](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041605316.png)

#### 3. 空闲存储空间管理

 ![image-20220404160906518](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041609584.png)

```js
// 位示图法： 1代表占用， 0代表空
```

![image-20220404161110426](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041614019.png)

![image-20220404162316390](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041623608.png)

#### 4. 数据传输控制问题

![image-20220404162411112](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041624178.png)

#### 5. 虚设备和SPOOLiNG

![image-20220404163449041](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041634113.png)

### 微内核操作系统

![image-20220404163918914](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202204041641637.png)

## 数据库



















## 设计模式

### uml类图

![image-20220329142910849](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291429965.png)

![image-20220329143051785](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291430855.png)

![image-20220329144503911](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291445999.png)

![image-20220329143554213](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291435282.png)

![image-20220329143611767](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291436838.png)

![image-20220329143633674](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291436742.png)

![image-20220329143649453](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291436538.png)

### 观察者模式

定义： 定义对象之间的一对多依赖， 让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时他的所有依赖者都会收到通知并更新

```java
package Observer;

import java.util.ArrayList;
import java.util.List;

public class ObserverTest {

    public static void main(String[] args) {

        Subject subject = new Subject();
        Task1 task1 = new Task1();
        subject.addObserver(task1);
        Task2 task2 = new Task2();
        subject.addObserver(task2);
        subject.notifyObserver("数据第二次改变");
        System.out.println("--------------------------");
        subject.removeObserver(task1);
        subject.notifyObserver("数据第一次改变");

    }

}

// 定义了一个主题类
class Subject {
    // 观察者（任务）的容器
    private List<Observer> containers = new ArrayList<>();
    // 增加观察者 （任务）
    public void addObserver(Observer observer) {
        containers.add(observer);
    }
    // 删除观察者 （任务）
    public void removeObserver(Observer observer) {
        containers.remove(observer);
    }
    // 通知所有观察者 （发布所有的任务）
    public void notifyObserver(Object object) {
        for (Observer item: containers) {
            item.update(object);
        }
    }
}

// 观察者接口
interface Observer {

    void update(Object object);

}

// 实际任务1
class Task1 implements Observer {

    @Override
    public void update(Object object) {
        System.out.println("Task1 received" + object);
    }

}

// 实际任务2
class Task2 implements Observer {

    @Override
    public void update(Object object) {
        System.out.println("Task2 received" + object);
    }

}
```

优点： 

1. 符合开闭原则， 在不改变原来的基础上， 可以轻松的添加监听者
2. 可以在运行时建立对象之间的关系

[观察者模式案例 浅显易懂](https://blog.csdn.net/itachi85/article/details/50773358?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164853513816782246428871%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164853513816782246428871&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-50773358.142^v5^article_score_rank,143^v6^control&utm_term=%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187)

[观察者模式案例 浅显易懂](https://blog.csdn.net/weixin_43570367/article/details/104954255?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164853513816782246428871%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164853513816782246428871&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-104954255.142^v5^article_score_rank,143^v6^control&utm_term=%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187)

### 命令模式

```java
package Design.CommandTest;

public class CommandTest {

    public static void main(String[] args) {

        SaveButton saveButton = new SaveButton();
        TextBox box = new TextBox();

        PrintCommand printCommand = new PrintCommand(box);
        saveButton.bindCommand(printCommand);

        box.setContext("啊呜啊呜");
        saveButton.doPrint();

    }

}


class SaveButton {

    private Command command;

    public void bindCommand(Command command) {
        this.command = command;
    }

    public void doPrint() {
        command.execute();
    }

}

class PrintService {

    public void print(String text) {
        System.out.println(text);
    }

}

interface Command {
    void execute();
}

class PrintCommand implements Command {

    private PrintService serviceProvider = new PrintService();
    private  TextBox box;

    public PrintCommand(TextBox box) {
        this.box = box;
    }

    @Override
    public void execute() {
        serviceProvider.print(box.getContext());
    }

}

class TextBox {

    private String context;

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }

}
```

### 装饰模式

定义： 在不改变对象原有功能的基础上， 将功能附加到对象上（只是装饰， 并非完全需要使用）

```java
package DecoratorTest;

public class DecoratorTest {

    public static void main(String[] args) {

        Component component = new ConcreteComponent();
        component.operation();

        System.out.println("--------------------");

        Component addComponent = new ConcreteDecorate2(new ConcreteDecorate1(new ConcreteComponent()));
        addComponent.operation();


    }

}

// 应用接口
interface Component {

    void operation();

}

// 具体基础功能的实现
class ConcreteComponent implements  Component {

    @Override
    public void operation() {
        System.out.println("拍照");
    }

}

// 这个接口用来拓展基础功能
abstract class Decorate implements Component {

    Component component;

    public Decorate(Component component) {
        this.component = component;
    }

}

// 具体的实现拓展功能 1
class ConcreteDecorate1 extends Decorate {

    public ConcreteDecorate1(Component component) {
        super(component);
    }

    @Override
    public void operation() {

        component.operation();
        System.out.println("添加美颜");
    }

}

// 具体的实现拓展功能 2
class ConcreteDecorate2 extends Decorate {

    public ConcreteDecorate2(Component component) {
        super(component);
    }

    @Override
    public void operation() {

        component.operation();
        System.out.println("添加滤镜");
    }

}
```

应用场景： 

1. 拓展一个类的功能， 给一个类添加附加职责

优点： 

1. 在不改变原有对象的情况下给对象一个拓展功能

2. 使用不同的组合可以有不同的效果

3. 符合开闭原则

### 适配器模式

定义： 将一个类的接口转换为用户希望的另一个接口， 使得原本不能兼容的接口得以一起工作

#### 对象适配器

```java
package Design.Adapter;

public class AdapterTest1 {

    public static void main(String[] args) {
        // 对象适配器模式 (写法一)
        Adaptee adaptee = new Adaptee();
        Target target = new Adapter(adaptee);
        target.output5v();

    }

}

// 原始电压
class Adaptee {

    public int output220v() {
        return 220;
    }

}

// 目标适配电压
interface Target {

    int output5v();

}

// 适配器
class Adapter implements Target {

    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public int output5v() {
        int i = adaptee.output220v();
        System.out.println("原始电压： " + i + "v; -> 输出电压： 5v");
        return 5;
    }

}
```

#### 类适配器模式

```java
package Design.Adapter;

public class AdapterTest2 {

    public static void main(String[] args) {
        // 类适配器模式 (写法二)
        Adapter adapter = new Adapter();
        adapter.output5v();
    }

}

// 原始
class Adaptee {

    public int output220v() {
        return 220;
    }

}

// 目标
interface Target {
    int output5v();
}

// 适配器
class Adapter extends Adaptee implements Target {

    @Override
    public int output5v() {
        int i = output220v();
        // ~ ~ ~
        System.out.println("原始电压： " + i + "v; -> 输出电压： 5v");
        return 5;
    }

}
```

优点： 

符合单一职责原则

符合开闭原则

### 外观模式

外观模式(Facade Pattern)：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

比如，我们在一个类中调用其余几个类的方法，并且按照一定顺序，这就属于外观模式。

![MarkdownPhotos/master/CSDNBlogs/DesignPatterns/facade.png](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203310820990.png)

这个模式不用刻意去学，因为在平时我们就会经常的使用它，只是我们不知道而已。

```java
package Design.FacadeTest;

public class FacadeTest {

    public static void main(String[] args) {

        new Facade().prove();
        
    }

}

class Facade {

    subFlow1 s1 = new subFlow1();
    subFlow2 s2 = new subFlow2();
    subFlow3 s3 = new subFlow3();

    boolean prove() {
        return s1.isTrue()&&s2.isOk()&&s3.isGoodMan();
    }
    
    boolean prove2() {
        return s1.isTrue()&&s2.isOk();
    }

    boolean prove3() {
        return s1.isTrue()&&s3.isGoodMan();
    }
}

class subFlow1 {
    Boolean isTrue() {
        return true;
    }
}

class subFlow2 {
    Boolean isOk() {
        return true;
    }
}

class subFlow3 {
    Boolean isGoodMan() {
        return true;
    }
}
```

优点：

- 遵守“迪米特法则”。外观模式对客户端屏蔽子系统，客户端不需要了解子系统，直接访问外观类即可。
  简化了客户端代码。客户端只需要将请求发送给Facade，减少了客户处理的对象的数目。
  解耦。实现了客户端和子系统的松耦合关系。 

缺点：

- 违背了“开闭原则”。在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码。
  


















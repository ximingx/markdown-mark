## 设计模式

### uml类图

![](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291429965.png)

#### 1. 类

![image-20220329143051785](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291430855.png)

#### 2. 接口

![image-20220329144503911](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291445999.png)

#### 3. 泛化

![image-20220329143554213](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291435282.png)

#### 4. 实现

![image-20220329143611767](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291436838.png)

#### 5. 关联

![image-20220329143633674](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291436742.png)

#### 6. 依赖

![image-20220329143649453](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203291436538.png)

### 观察者模式

定义： 定义对象之间的一对多依赖， 让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时他的所有依赖者都会收到通知并更新

```java
package Observer;

import java.util.ArrayList;
import java.util.List;

public class ObserverTest {

    public static void main(String[] args) {

        Subject subject = new Subject();
        Task1 task1 = new Task1();
        subject.addObserver(task1);
        Task2 task2 = new Task2();
        subject.addObserver(task2);
        subject.notifyObserver("数据第二次改变");
        System.out.println("--------------------------");
        subject.removeObserver(task1);
        subject.notifyObserver("数据第一次改变");

    }

}

// 定义了一个主题类
class Subject {
    // 观察者（任务）的容器
    private List<Observer> containers = new ArrayList<>();
    // 增加观察者 （任务）
    public void addObserver(Observer observer) {
        containers.add(observer);
    }
    // 删除观察者 （任务）
    public void removeObserver(Observer observer) {
        containers.remove(observer);
    }
    // 通知所有观察者 （发布所有的任务）
    public void notifyObserver(Object object) {
        for (Observer item: containers) {
            item.update(object);
        }
    }
}

// 观察者接口
interface Observer {

    void update(Object object);

}

// 实际任务1
class Task1 implements Observer {

    @Override
    public void update(Object object) {
        System.out.println("Task1 received" + object);
    }

}

// 实际任务2
class Task2 implements Observer {

    @Override
    public void update(Object object) {
        System.out.println("Task2 received" + object);
    }

}
```

优点： 

1. 符合开闭原则， 在不改变原来的基础上， 可以轻松的添加监听者
2. 可以在运行时建立对象之间的关系

[观察者模式案例 浅显易懂](https://blog.csdn.net/itachi85/article/details/50773358?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164853513816782246428871%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164853513816782246428871&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-50773358.142^v5^article_score_rank,143^v6^control&utm_term=%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187)

[观察者模式案例 浅显易懂](https://blog.csdn.net/weixin_43570367/article/details/104954255?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164853513816782246428871%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=164853513816782246428871&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-104954255.142^v5^article_score_rank,143^v6^control&utm_term=%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&spm=1018.2226.3001.4187)

### 命令模式

```java
package Design.CommandTest;

public class CommandTest {

    public static void main(String[] args) {

        SaveButton saveButton = new SaveButton();
        TextBox box = new TextBox();

        PrintCommand printCommand = new PrintCommand(box);
        saveButton.bindCommand(printCommand);

        box.setContext("啊呜啊呜");
        saveButton.doPrint();

    }

}


class SaveButton {

    private Command command;

    public void bindCommand(Command command) {
        this.command = command;
    }

    public void doPrint() {
        command.execute();
    }

}

class PrintService {

    public void print(String text) {
        System.out.println(text);
    }

}

interface Command {
    void execute();
}

class PrintCommand implements Command {

    private PrintService serviceProvider = new PrintService();
    private  TextBox box;

    public PrintCommand(TextBox box) {
        this.box = box;
    }

    @Override
    public void execute() {
        serviceProvider.print(box.getContext());
    }

}

class TextBox {

    private String context;

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }

}
```

### 装饰模式

定义： 在不改变对象原有功能的基础上， 将功能附加到对象上（只是装饰， 并非完全需要使用）

```java
package DecoratorTest;

public class DecoratorTest {

    public static void main(String[] args) {

        Component component = new ConcreteComponent();
        component.operation();

        System.out.println("--------------------");

        Component addComponent = new ConcreteDecorate2(new ConcreteDecorate1(new ConcreteComponent()));
        addComponent.operation();


    }

}

// 应用接口
interface Component {

    void operation();

}

// 具体基础功能的实现
class ConcreteComponent implements  Component {

    @Override
    public void operation() {
        System.out.println("拍照");
    }

}

// 这个接口用来拓展基础功能
abstract class Decorate implements Component {

    Component component;

    public Decorate(Component component) {
        this.component = component;
    }

}

// 具体的实现拓展功能 1
class ConcreteDecorate1 extends Decorate {

    public ConcreteDecorate1(Component component) {
        super(component);
    }

    @Override
    public void operation() {

        component.operation();
        System.out.println("添加美颜");
    }

}

// 具体的实现拓展功能 2
class ConcreteDecorate2 extends Decorate {

    public ConcreteDecorate2(Component component) {
        super(component);
    }

    @Override
    public void operation() {

        component.operation();
        System.out.println("添加滤镜");
    }

}
```

应用场景： 

1. 拓展一个类的功能， 给一个类添加附加职责

优点： 

1. 在不改变原有对象的情况下给对象一个拓展功能

2. 使用不同的组合可以有不同的效果

3. 符合开闭原则

### 适配器模式

定义： 将一个类的接口转换为用户希望的另一个接口， 使得原本不能兼容的接口得以一起工作

#### 对象适配器

```java
package Design.Adapter;

public class AdapterTest1 {

    public static void main(String[] args) {
        // 对象适配器模式 (写法一)
        Adaptee adaptee = new Adaptee();
        Target target = new Adapter(adaptee);
        target.output5v();

    }

}

// 原始电压
class Adaptee {

    public int output220v() {
        return 220;
    }

}

// 目标适配电压
interface Target {

    int output5v();

}

// 适配器
class Adapter implements Target {

    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public int output5v() {
        int i = adaptee.output220v();
        System.out.println("原始电压： " + i + "v; -> 输出电压： 5v");
        return 5;
    }

}
```

#### 类适配器模式

```java
package Design.Adapter;

public class AdapterTest2 {

    public static void main(String[] args) {
        // 类适配器模式 (写法二)
        Adapter adapter = new Adapter();
        adapter.output5v();
    }

}

// 原始
class Adaptee {

    public int output220v() {
        return 220;
    }

}

// 目标
interface Target {
    int output5v();
}

// 适配器
class Adapter extends Adaptee implements Target {

    @Override
    public int output5v() {
        int i = output220v();
        // ~ ~ ~
        System.out.println("原始电压： " + i + "v; -> 输出电压： 5v");
        return 5;
    }

}
```

优点： 

符合单一职责原则

符合开闭原则

### 外观模式

外观模式(Facade Pattern)：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

比如，我们在一个类中调用其余几个类的方法，并且按照一定顺序，这就属于外观模式。

![MarkdownPhotos/master/CSDNBlogs/DesignPatterns/facade.png](https://raw.githubusercontent.com/ximingx/Figurebed/master/img/202203310820990.png)

这个模式不用刻意去学，因为在平时我们就会经常的使用它，只是我们不知道而已。

```java
package Design.FacadeTest;

public class FacadeTest {

    public static void main(String[] args) {

        new Facade().prove();
        
    }

}

class Facade {

    subFlow1 s1 = new subFlow1();
    subFlow2 s2 = new subFlow2();
    subFlow3 s3 = new subFlow3();

    boolean prove() {
        return s1.isTrue()&&s2.isOk()&&s3.isGoodMan();
    }
    
    boolean prove2() {
        return s1.isTrue()&&s2.isOk();
    }

    boolean prove3() {
        return s1.isTrue()&&s3.isGoodMan();
    }
}

class subFlow1 {
    Boolean isTrue() {
        return true;
    }
}

class subFlow2 {
    Boolean isOk() {
        return true;
    }
}

class subFlow3 {
    Boolean isGoodMan() {
        return true;
    }
}
```

优点：

- 遵守“迪米特法则”。外观模式对客户端屏蔽子系统，客户端不需要了解子系统，直接访问外观类即可。
  简化了客户端代码。客户端只需要将请求发送给Facade，减少了客户处理的对象的数目。
  解耦。实现了客户端和子系统的松耦合关系。 

缺点：

- 违背了“开闭原则”。在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码。

### 简单工厂模式

```java
package Design.Factory.simple;

public class simpleFactory {

    public static Product createProduct(String type) {
        if (type.equals("A")) {
            return new productA();
        } else {
            return  new productB();
        }
    }

    public static void main(String[] args) {
        Product product = simpleFactory.createProduct("A");
        product.print();
    }

}

abstract class Product {
    public abstract void print();
}

class productA extends Product {
    @Override
    public void print() {
        System.out.println("product a");
    }
}

class productB extends Product {
    @Override
    public void print() {
        System.out.println("product b");
    }
}
```

优点： 实现对象创建和使用的分离

缺点： 不够灵活

### 工厂模式